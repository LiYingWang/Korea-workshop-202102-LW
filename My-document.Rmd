---
title: "Introduction to spatial data visulization and analysis Using R2"
author: "Liying Wang"
date: "2/22/2021"
output: html_document:
    keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#Sys.setlocale("LC_ALL","English") # for Windows users
```

# Introduction

In this workshop, you will learn how to use R to manipulate and visualize spatial data of interest to archaeologists. This rmd file is a demonstration of code and you will work on it step by step to get familiar with spatial data and basic analysis. There are three main topics covered in this workshop:

-Part 1: making maps, including regional map and site map
-Part 2: spatial data manipulation and visualization for raster and vector data
-Part 3: spatial data analysis and hypothesis testing, including density plot, and hypothesis testing site distributions

Before getting started, make sure you have all packages we will use! If not, run the code below:
 
## Set up 1: install packages 

Copy and paste the code to your console and run it: 
install.packages(c("rnaturalearth", "rnaturalearthdata", "ggplot2", "tidyverse", "sf", "sp","shadowtext", "ggmap", "ggspatial", "raster", "spatstat", "maptools", "devtools"))

If you see a message "Do you want to install from sources the package which needs compilation?" Type "No" on your console, press Enter, and it will continue to download.

Copy and paste the code to your console and run it: 
devtools::install_github('3wen/legendMap')

## Set up 2: download files 

```{r download-workdshop-data}
if (!require("usethis")) install.packages("usethis") # to install usethis
usethis::use_course("LiYingWang/Korea-workshop-202102-LW")
```

# Making maps

Load world data and take a look at the data form, especially the "geometry" column where it stores the coordinates we need for making maps.

## Exercise 001: load data and make a regional map (7 mins)

```{r load-world-map-data}
library(rnaturalearth) # provides world map
library(rnaturalearthdata)

world <- ne_countries(scale = "medium", returnclass = "sf") # pulls country data 
class(world) # what class it is?
# type view(world) in your console to take a look at the data frame

library(ggplot2)

# plot basic world map 
ggplot(data = world) +
  geom_sf() + # adds a geometry stored in world
  theme_minimal()
```

Now, we want to plot Japan with some countries around it as our regional map. We may want to indicate the countries by adding name label on it. To do this, we need to get the center of the country for adding country labels, and then specify which countries we want to show their names on the map.


```{r create-text-labels}
library(tidyverse)
library(sf)

country_centre_coords <-
  as_tibble(st_coordinates(st_centroid(world$geometry))) # for the text labels

world_points <-
  world %>%
  bind_cols(country_centre_coords) %>%
  filter(name %in% c("Japan", "China", "Korea", "Taiwan", "Mongolia"))

library(shadowtext)

# plot map
Korea_in_Asia <-
  ggplot(data = world) +
  geom_sf() +
  geom_shadowtext(data= world_points, # add texts
                  aes(x = X, y = Y,
                      label = name),
                  color='black',
                  bg.colour='white',
                  size = 3.5,
                  position = position_nudge(y = 0, x = 3)) +
  coord_sf(xlim = c(100, 155), # zoom in the area of interest
           ylim = c(20, 60), 
           expand = FALSE) + # match the limits we provide
  scale_x_continuous(breaks = seq(100, 150, by = 15)) +
  scale_y_continuous(breaks = seq(20, 60, by = 15)) +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank())

Korea_in_Asia
```

We also want to make a map with archaeological sites we are interested in. Since we would add points for sites, we have to specify the coordinates of site location first.

## Exercise 002: make a site map (7 mins)

```{r site-location}
# add site location
site_location <-
  data.frame(location = c("A", "B"),
             lon = c(126.5, 128),
             lat = c(34.6, 35.8))

library(ggmap)
library(ggspatial)
library(legendMap)

local_map <- ggmap(get_stamenmap(rbind(as.numeric(c(126, 34.2,
                                                    128.5, 36.5))), zoom = 9)) # define the range

site_Korea <- 
  local_map +
  geom_point(data = site_location, # add a layer of sites
             aes(x = lon,
                 y = lat),
             size = 3,
             color = "red") +
  geom_shadowtext(data = site_location, # add texts 
                  aes(x = lon,
                      y = lat,
                      label = location),
                  size = 5,
                  position = position_nudge(y = - 0.07),
                  check.overlap = TRUE) +
  coord_sf(xlim = c(126, 128.5), # define the range
           ylim = c(34.2, 36.5),
           expand = FALSE) +
  scale_x_continuous(breaks = seq(126, 128.5, by = 1)) + 
  scale_y_continuous(breaks = seq(34.2, 36.5, by = 0.5)) +
  legendMap::scale_bar( 
    lon = 127.8,
    lat = 34.3,
    legend_size = 3,
    # distance of one section of scale bar, in km
    distance_lon = 25,
    # height of the scale bar, in km
    distance_lat = 2,
    # distance between scale bar and units, in km
    distance_legend = 7,
    # units of scale bar
    dist_unit = "km",
    # add the north arrow
    orientation = TRUE,
    # length of N arrow, in km
    arrow_length = 4,
    # distance between scale bar & base of N arrow, in km
    arrow_distance = 13,
    # size of letter 'N' on N arrow, in km
    arrow_north_size = 4) +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank())

site_Korea
```

We can save the map using ggsave function below the plot we would like to save.

```{r save-map}
# save the map to your folder 
ggsave(here::here("Korea-site-map.jpg"),
       width = 150,
       height = 150,
       dpi = 300,
       units = "mm")
```

# Spatial data manipulation and visualization 

The raster data is DEM data downloaded from http://www.earthenv.org/DEM.

We want to crop the area that matches the site map from this DEM data. Here, we use coordinates to create a data frame, convert it to a spatial object, and then use it to crop the raster.

## Exercise 003: crop an area from raster data (7 mins)

```{r get-raster-data}
library(raster)

# read in data from data folder
Korea_raster1 <- raster(here::here("data/EarthEnv-DEM90_N35E125/EarthEnv-DEM90_N35E125.bil"))
Korea_raster2 <- raster(here::here("data/EarthEnv-DEM90_N35E125/EarthEnv-DEM90_N30E125.bil"))

# combine two raster tiles
Korea_raster <- merge(Korea_raster1, Korea_raster2) 

# assign coordinate reference system
crs(Korea_raster) <- "+proj=lcc +lat_1=41.03333333333333 +lat_2=40.66666666666666 +lat_0=40.16666666666666 +lon_0=-74 +x_0=300000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=us-ft +no_defs"

plot(Korea_raster) # take a look at raster data

# define the area that we want to crop from the DEM
x_coord <- c(126, 126, 128.5, 128.5, 126)
y_coord <- c(34.2, 36.5, 36.5, 34.2, 34.2)
xym <- cbind(x_coord, y_coord)

library(sp)
p = Polygon(xym) # convert the matrix to polygon
ps = Polygons(list(p),1) # make lists
sps = SpatialPolygons(list(ps)) # convert to Spatial Polygons
crs(sps) <- crs(Korea_raster) # define coordinate reference system
crop_DEM <- crop(Korea_raster, sps) # crop a raster to the extent of specified spatial object
summary(crop_DEM)
plot(crop_DEM)
```

We can plot the raster data using ggplot function, which allows us to modify axis, legend, and labels displayed on the plot. To use ggplot, we need to convert the cropped raster to a dataframe.

## Exercise 004: Extract elevation of sites from vector data (7 mins)

```{r plot-raster-data}
# cover to a dataframe for ggplot
crop_DEM_df <- as.data.frame(crop_DEM, xy = TRUE)
# plot
ggplot() +
  geom_raster(data = crop_DEM_df , aes(x = x, y = y, fill = layer)) +
  scale_fill_viridis_c(name = "Elevation") +
  coord_quickmap() # plot faster
```

Now, let's work on vector data and plot it on the raster. We import a shapefile which contains site locations we want to explore. We are curious about the distribution of archaeological sites and how they relate to the elevation of this area.

```{r read-shapefile}
crop_DEM_df <- as.data.frame(crop_DEM, xy = TRUE)
# example of archaeological sites
sites <- st_read("data/site_example.shp")

crop_DEM_df %>% 
  ggplot() + 
  geom_raster(aes(x = x, y = y, fill = layer)) +
  geom_sf(data = sites, aes(color = phase)) + # add site shapefile
  scale_color_manual(values=c("red", "black")) + # change default color
  scale_fill_viridis_c(name = "Elevation") +
  coord_sf() # all layers use a common CRS
```

We are curious about the elevation of the locations of archaeological sites, and would like to compare sites from two phases: early neolithic and late neolithic. Let's extract elevation and make a plot to compare sites from two phases

```{r elevation-boxplot-two-phases}
# convert sf (simple feature) to a spatial object
sp_sites <- as(sites, "Spatial")

# extract elevation for each site
elevation <- extract(crop_DEM, sp_sites, 
                     method = "simple") # use values for the cell a point falls in
sites <- cbind(sites, elevation)

sites %>% 
  ggplot(aes(phase, elevation)) + 
  geom_boxplot() +
  theme_minimal()
```

# Spatial data analysis and hypothesis testing

We may want to know the distribution pattern of the sites across this area. We can visualize the density to check any hot spots using kernal density estimation.

## Exercise 5: make a kernel density plot (5 mins)

```{r kernel-plot-all-sites}
library(spatstat)
library(maptools)
crop_DEM_df <- as.data.frame(crop_DEM, xy = TRUE)

# get two columns, one longitude and another is latitude
sites_coords <-
  sites %>% 
  st_coordinates() %>% 
  as.data.frame 

# convert to ppp object that represent a two-dimensional point pattern
sites_ppp <- ppp(x = sites_coords$X,
                 y = sites_coords$Y,
                 range(crop_DEM_df$x), # set window, means the extent of an area
                 range(crop_DEM_df$y))

K1 <- density(sites_ppp) 

plot(K1, main=NULL, las=1)
contour(K1, add=TRUE)
```

Is the hot spots we observed significant? We can simulate the site locations and testing our hypothesis to determine if the distribution is random or not random.

## Exercise 6: hypothesis testing on sptail distribution (7 mins)

```{r simulation-all-sites}
# get the mean distance for our observation
ann_p <- mean(nndist(sites_ppp, k=1))
n     <- 100 # Number of simulations

ann_r <- vector(length = n) # an object for storing simulated ANN values

# simulation
for (i in 1:n){
  rand_p   <- rpoint(sites_ppp$n, 
                     win = as.owin(crop_DEM_df))  # generate random point locations
  ann_r[i] <- mean(nndist(rand_p, k=1))  # tally the ANN values
}

# plot the histogram and add our observed ANN value line
hist(ann_r, main=NULL, las=1, breaks=40, 
     col = "bisque", 
     xlim = range(ann_p, ann_r))
abline(v = ann_p, col="blue") # the observed value
```

We have looked at the distribution of sites all together, but what if we want to focus on sites from a phase; for example, we want to explore early neolithic sites. We can filter out the phase we want and use the same method to test the distribution patterns of early neolithic sites.

## Additional exercise: Do the early neolithic sites ramdonly distributed or non-ramdonly distributed? The pattern is clustterd or dispersed? 

```{r kernel-plot-kofun}
sites_coords_early_neo <-
  sites %>% 
  st_coordinates() %>% 
  as.data.frame () %>% 
  bind_cols(sites) %>% 
  filter(phase == "early neolithic")

sites_ppp_early_neo <- (ppp(x = sites_coords_early_neo$X,
                                 y = sites_coords_early_neo$Y,
                                 range(crop_DEM_df$x),
                                 range(crop_DEM_df$y))) 

K2 <- density(sites_ppp_early_neo) 

plot(K2, main=NULL, las=1)
contour(K2, add=TRUE)
```

```{r simulation-kofun}
ann_p <- mean(nndist(sites_ppp_early_neo, k=1))
n     <- 100 # Number of simulations

ann_r <- vector(length = n) # an object for storing simulated ANN values

# simulation
for (i in 1:n){
  rand_p   <- rpoint(sites_ppp_early_neo$n, 
                     win = as.owin(crop_DEM_df))  # Generate random point locations
  ann_r[i] <- mean(nndist(rand_p, k=1))  # Tally the ANN values
}

# plot the histogram and add our observed ANN value line
hist(ann_r, main=NULL, las=1, breaks=40, 
     col = "bisque", 
     xlim = range(ann_p, ann_r))
abline(v = ann_p, col="blue")
```
